Synthetic Metagenomics Simulator v 1.1 April 2013

This pipeline is used to simulate illumina shotgun sequencing data. The major
task of this pipeline is to generate metagenomic data while whole genome
sequencing data can also be created. Using sfle to drive, you should place
this project in sfle/input folder as an independent subfolder.

======User-defined constant======

Several user-defined constants can be modified within Sconscript.

1. Nunbmer of synthesized reads per community.

2. Input reference genomes and gene annotation files path.
This path should contain fasta files for genomes' sequence and corresponding 
gene annotation files. We use an IMG dataset to drive the pipeline, so the
file names should be compatible with the IMG taxon id which can be found in
the IMG taxontable we distributed. This table is located at
input/Taxontable_demo. Users can replace it and details can be found below. We
highly recommend you use the IMG dataset.

3. Minimum length of contigs that can be kept in the checked genome sequnence
data.

======Input Files======

1. Relative abundance files for community (required)
The only input files that should be provided by users are the abundance files.

Where to put it
You shall put your relative abundance files in input folder.

Format
1) Tab-delimited plain text files with two columns.
2) First column is the name of bugs, usually this should be a name specifying
the level of each name file with an abbreviate word plus underscore as prefix.
See attached example. This requirement might be removed in future.
3) Second column is the relative abundance for each bug. It should be the
fraction of each bug in the community or normalized by some constant.

Example
Example community abundance files can be found in input/abunRef_demo.txt.

2. IMG taxonomy table
We distribute this table (input/Taxontable_demo) which is compatible with our 
test IMG genomes dataset. You may want to change it if you use a different 
genomes datasets. This table is used to map taxonomy names to file names in 
the dataset (either genome sequence file or gene annotation files). Be aware 
that if your table's format is not the same of input/Taxontable_demo, our 
pipeline will fail due to inability to map correctly.

We use IMG dataset version 3.5 updated in summer 2012.

3. Error model
Optionally, users can also supply an error model file as input. This should be
generated by GemErr.py and should be a collection of information in some real
sequencing data. For details of generating the error model data by GemErr,
please refering to GemSIM homepage (http://sourceforge.net/projects/gemsim/).

We have distributed an error model file within our repository. You can find it
in input/ill100v5_p.gzip. It is based on aligned Illumina sequencing data. More
details can be found in GemSIM paper (doi:10.1186/1471-2164-13-74).

======Output Files=====

1. Synthesized sequencing data
We set the sequencing producing paired-end reads as default. The output files
for each input community are two fastq files with _fir and _sec identifiers 
and a compressed BAM file.

2. Gold standard files for genes, pathways and modules
Currently we only generate gold standard abundance files for genes. You can
find them in output/Gene. We will add files for pathways and modules in
near future.

3. Log files
Log files contain some important information concerning taxonomy name mapping
and synthesizing sequencing process. You can find them in output/Log.
_convert.log is for name mapping, _check.log is for short contigs check and
_synseq.log is for sythesizing process.

=======Details of Pipeline======

1. Intermediate processes:

1.1 Convert user given abundance files into GemReads compatible abundance
files

The GemReads compatible abundance file is very similar to the user-defined
abundance file except that the first column is the exact file names of genome
sequence files in the input database. Since the users always want to specify
the real name of the bugs, we will do this mapping in the pipeline so the
GemReads can be drived correctly.

1.2 Check genome sequence files

Normally, the genome sequence files can contain more than one sequence. In
this case, they are called contigs. The length for the contigs in one sequence
file can vary dramatically. The too short contigs are very likely to crash
GemReads. The reason for this is because by default, we generate paired-end
reads by GemReads and it will help you choose an empirical insert length
for the paired reads. This empirical data is drawn from the real Illumina
sequencing data which is recorded in the error model file we have included in
this project.

For Illumina run, the typical length for each end of a pair is around 100 bps
and the error model we used consider the minimal insert length as around
300 bps. On the other hand, GemReads does not concatenate all contigs in one
genome into one and randomly pick one position to start. It assigns a
length-based probability to each contig in one genome sequence file and pick
one contig randomly based on this probability. The picked contig will be
treated as the template from which the synthetic sequencing data are drawn.

If one contig in the genome sequence file is shorter than 300 bps, it is 
likely that we cannot slice a typcial Illumina PE reads from it which will
cause GemReads crash.

To deal with this issue, we are performing one filtering procedure to delete the
too short contigs in the input genome files. This is usually necessary for the
draft genome files which are always highly fragmented. The threshold for
length is user-defined.

2. Sequencing simulation

We use GemSIM (doi:10.1186/1471-2164-13-74) to carry out the simulation of
Illumina sequencing. GemSIM is composed of several separate scripts and the
specific script we implement in our pipeline is GemReads.py. This script can
simulate both single genome or metagenome sequencing result. In this pipeline,
the script is working under metagenomic mode by default.

The relative abundance will be treaded as abundance of real bugs rather than
sequences belong to each bug. So for two bugs whose genomes have large
distinction in length, even if their relative abundance is the same, the
fraction of sequences belong to each bug can be very different.

3. Gold standard files generate

3.1 Bugs abundance gold standard file

This is the input abundance file.

3.2 Genes abundance file

This is done by reading the annotation files in IMG dataset for each input
bug. We count the frequency of all different KO's in each bug recorded in the
annotation files and normalize this count by the bug's relative abundance. The
resulting relative abundance of each KO with regard to the whole community is
the sum of all the individual bug's normalized KO frequency. This relative
abundance can be multiplied by arbitrary positive real number.
